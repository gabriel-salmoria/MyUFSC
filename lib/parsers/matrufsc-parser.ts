/**
 * Parser for MatrUFSC format to our timetable format
 * 
 * This parser converts data from the format generated by MatrUFSC scraper
 * into the format used by our timetable component.
 */

import { Course } from "@/types/curriculum"
import { StudentCourse, CourseStatus } from "@/types/student-plan"

// Type definitions for the actual MatrUFSC data format (array-based)
type MatrufscCampus = string;
type MatrufscTime = string; // Format: "3.1330-2 / CCE101" (day.time-credits / place)
type MatrufscTeacher = string;

// Output types for our timetable
interface ClassSchedule {
  day: number;            // 0-6 for Monday-Sunday
  startTime: string;      // HH:MM format
  endTime: string;        // HH:MM format
}

interface Professor {
  professorId: string;    // Generated ID
  name: string;           // Professor name
  classNumber: string;    // Class number
  schedule: string;       // Human readable schedule (e.g., "Terça/Quinta 13:30-15:10")
  enrolledStudents: number; // Number of enrolled students
  maxStudents: number;    // Maximum students
}

interface ProfessorsMap {
  [courseId: string]: Professor[];
}

// Structure that mimics the schedule.json format
interface ScheduleData {
  [key: string]: ClassSchedule[] | ProfessorsMap | undefined;
  professors: ProfessorsMap;
}

/**
 * Parses a time string from MatrUFSC format
 * Example: "3.1330-2 / CCE101" => { day: 2, startTime: "13:30", endTime: "15:10", place: "CCE101" }
 */
function parseTimeString(timeString: MatrufscTime): {
  day: number;
  startTime: string;
  endTime: string;
  place: string;
} {
  // Split into time part and place part
  const [timePart, placePart] = timeString.split(' / ');
  
  // Split time part into day, time and credits
  const [dayAndTime, creditsStr] = timePart.split('-');
  const [dayStr, timeStr] = dayAndTime.split('.');
  
  // Parse day (convert from 1-7 to 0-6 for JavaScript)
  const day = parseInt(dayStr) - 2; // MatrUFSC uses 2=Mon, 3=Tue, etc. We need 0=Mon, 1=Tue
  if (day < 0) return { day: day + 7, startTime: timeStr.substr(0, 2) + ":" + timeStr.substr(2), endTime: "", place: placePart || "" };
  
  // Parse time
  const startTime = timeStr.substr(0, 2) + ":" + timeStr.substr(2);
  
  // Calculate end time based on credits
  const credits = parseInt(creditsStr);
  let endTime = "";
  
  // Each credit typically represents a 50-minute class
  if (startTime && credits) {
    const [hours, minutes] = startTime.split(':').map(num => parseInt(num));
    const endMinutes = minutes + (credits * 50);
    const endHours = hours + Math.floor(endMinutes / 60);
    const newMinutes = endMinutes % 60;
    endTime = `${endHours.toString().padStart(2, '0')}:${newMinutes.toString().padStart(2, '0')}`;
  }
  
  return {
    day,
    startTime,
    endTime,
    place: placePart || ""
  };
}

/**
 * Generate a human-readable schedule string for professors
 */
function generateReadableSchedule(times: ClassSchedule[]): string {
  if (!times.length) return "";

  // Map days numbers to names
  const daysMap: Record<number, string> = {
    0: "Segunda",
    1: "Terça",
    2: "Quarta",
    3: "Quinta",
    4: "Sexta",
    5: "Sábado",
    6: "Domingo"
  };

  // Group by unique time slot
  const timeGroups: Record<string, number[]> = {};
  
  times.forEach(time => {
    const timeKey = `${time.startTime}-${time.endTime}`;
    if (!timeGroups[timeKey]) {
      timeGroups[timeKey] = [];
    }
    timeGroups[timeKey].push(time.day);
  });
  
  // Format each time group
  const result = Object.entries(timeGroups).map(([timeKey, days]) => {
    const [startTime, endTime] = timeKey.split('-');
    const dayNames = days.map(day => daysMap[day]).join('/');
    return `${dayNames} ${startTime}-${endTime}`;
  });
  
  return result.join(', ');
}

/**
 * Converts MatrUFSC data into our timetable format
 * The input data is in the format:
 * {
 *   "DATA": "26/03/25 - 14:50",
 *   "FLO": [ 
 *     ["ACL5132", "CITOLOGIA CLÍNICA", "Citologia Clínica", [ [class details], [class details] ] ],
 *     ...
 *   ]
 * }
 */
export function parseMatrufscData(data: any): ScheduleData {
  const result = {
    professors: {} as ProfessorsMap
  } as ScheduleData;
  
  // Process each campus and its courses
  Object.entries(data).forEach(([campusKey, campusValue]) => {
    // Skip the timestamp field
    if (campusKey === 'DATA') return;
    
    // Process campus data (array of course arrays)
    const courses = campusValue as any[];
    
    // Iterate through each course
    courses.forEach(courseArray => {
      if (!Array.isArray(courseArray) || courseArray.length < 4) return;
      
      const courseId = courseArray[0] as string;
      const courseTitle = courseArray[2] as string;
      const courseClasses = courseArray[3] as any[];
      
      // Skip if course ID or classes are missing
      if (!courseId || !Array.isArray(courseClasses)) return;
      
      // Create arrays for this course's schedule and professors
      const courseSchedules: ClassSchedule[] = [];
      const professors: Professor[] = [];
      
      // Process each class in this course
      courseClasses.forEach(classArray => {
        if (!Array.isArray(classArray) || classArray.length < 10) return;
        
        const classId = classArray[0] as string;
        const classHours = classArray[1] as number;
        const labels = classArray[2] as string[];
        const totalSlots = classArray[3] as number;
        const filledSlots = classArray[4] as number;
        const specialStudents = classArray[5] as number;
        const openSlots = classArray[6] as number;
        const waitingForSlot = classArray[7] as number;
        const times = classArray[8] as string[];
        const teachers = classArray[9] as string[];
        
        // Process class times
        const classSchedules: ClassSchedule[] = [];
        
        // Check if times is an array before processing
        if (Array.isArray(times)) {
          times.forEach(timeDef => {
            const { day, startTime, endTime } = parseTimeString(timeDef);
            
            // Skip invalid times
            if (startTime) {
              classSchedules.push({
                day,
                startTime,
                endTime
              });
            }
          });
        }
        
        // Create professor entry
        const professorId = `${courseId}_${classId}`;
        const professorName = Array.isArray(teachers) ? teachers.join(', ') : "";
        
        professors.push({
          professorId,
          name: professorName,
          classNumber: classId,
          schedule: generateReadableSchedule(classSchedules),
          enrolledStudents: filledSlots,
          maxStudents: totalSlots
        });
        
        // Add class schedules to course schedules
        courseSchedules.push(...classSchedules);
      });
      
      // Add course schedules to result
      if (courseSchedules.length > 0) {
        result[courseId] = courseSchedules;
        
        // Add professors data
        if (professors.length > 0) {
          result.professors[courseId] = professors;
        }
      }
    });
  });
  
  return result;
}

/**
 * Creates student courses from MatrUFSC courses in array format
 */
export function createStudentCoursesFromMatrufsc(
  matrufscCourses: any[],
  status: CourseStatus = CourseStatus.IN_PROGRESS
): StudentCourse[] {
  return matrufscCourses
    .filter(courseArray => Array.isArray(courseArray) && courseArray.length >= 4)
    .map(courseArray => {
      const courseId = courseArray[0] as string;
      const courseTitle = courseArray[2] as string;
      const courseClasses = courseArray[3] as any[];
      
      // Get credits from the first class if available
      let credits = 0;
      if (Array.isArray(courseClasses) && courseClasses.length > 0 && Array.isArray(courseClasses[0])) {
        credits = (courseClasses[0][1] as number) / 18; // Convert hours to credits (assuming 18 hours = 1 credit)
      }
      
      // Create a course object
      const course: Course = {
        id: courseId,
        name: courseTitle,
        credits,
        phase: 0, // Default phase, would need to be updated based on curriculum
      };
      
      // Create student course with required properties
      return {
        course,
        status,
        // Use first class ID if available
        class: Array.isArray(courseClasses) && courseClasses.length > 0 && Array.isArray(courseClasses[0]) 
          ? courseClasses[0][0] as string 
          : undefined
      } as StudentCourse;
    });
}

/**
 * Extracts data for a specific campus from MatrUFSC data
 * This helps reduce memory usage by only working with one campus at a time
 */
export function extractCampusData(data: any, campusCode: string): any {
  if (!data || typeof data !== 'object') {
    console.error('Invalid MatrUFSC data provided');
    return null;
  }

  // Create a new object with just the timestamp and the requested campus
  const result: Record<string, any> = {
    DATA: data.DATA || new Date().toLocaleString()
  };

  // Add the campus data if it exists
  if (data[campusCode] && Array.isArray(data[campusCode])) {
    result[campusCode] = data[campusCode];
    return result;
  }

  console.error(`Campus ${campusCode} not found in MatrUFSC data`);
  return null;
} 