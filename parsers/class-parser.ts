/**
 * Parser for MatrUFSC format to our timetable format
 * 
 * This parser converts data from the format generated by MatrUFSC scraper
 * into the format used by our timetable component.
 */

import { Course } from "@/types/curriculum"
import { StudentCourse, CourseStatus } from "@/types/student-plan"

// Basic types
interface ClassSchedule {
  day: number;            // 0-6 for Monday-Sunday
  startTime: string;      // HH:MM format
  endTime: string;        // HH:MM format
  location?: string;      // Classroom building/room
}

interface Professor {
  professorId: string;    // Generated ID
  name: string;           // Professor name
  classNumber: string;    // Class number
  schedule: string;       // Human readable schedule
  enrolledStudents: number;
  maxStudents: number;
}

// Output structure
interface ScheduleData {
  [courseId: string]: ClassSchedule[] | Record<string, Professor[]> | undefined;
  professors: Record<string, Professor[]>;
}

/**
 * Parses a time string from MatrUFSC format
 * Example: "3.1330-2 / CCE101" => { day: 2, startTime: "13:30", endTime: "15:10", location: "CCE101" }
 */
function parseTimeString(timeString: string): ClassSchedule {
  const [timePart, location = ""] = timeString.split(' / ');
  const [dayAndTime, creditsStr = "1"] = timePart.split('-');
  const [dayStr, timeStr] = dayAndTime.split('.');

  // Parse day (convert from MatrUFSC format to 0-6 for Mon-Sun)
  const day = parseInt(dayStr) - 2;
  const adjustedDay = day < 0 ? day + 7 : day;

  // Format start time
  const startTime = timeStr.substr(0, 2) + ":" + timeStr.substr(2);

  // Calculate end time based on credits (each credit = 50 min)
  const credits = parseInt(creditsStr);
  let endTime = startTime;

  if (startTime && credits) {
    const [hours, minutes] = startTime.split(':').map(num => parseInt(num));
    const endMinutes = minutes + (credits * 50);
    const endHours = hours + Math.floor(endMinutes / 60);
    const newMinutes = endMinutes % 60;
    endTime = `${endHours.toString().padStart(2, '0')}:${newMinutes.toString().padStart(2, '0')}`;
  }

  return {
    day: adjustedDay,
    startTime,
    endTime,
    location: location.trim()
  };
}

/**
 * Generate a human-readable schedule string
 */
function generateReadableSchedule(times: ClassSchedule[]): string {
  if (!times.length) return "";

  const daysMap = ["Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado", "Domingo"];
  const timeGroups: Record<string, { days: number[], location: string }> = {};

  // Group times by time slot
  times.forEach(time => {
    const timeKey = `${time.startTime}-${time.endTime}`;
    if (!timeGroups[timeKey]) {
      timeGroups[timeKey] = { days: [], location: time.location || "" };
    }
    timeGroups[timeKey].days.push(time.day);
  });

  // Format each time group
  return Object.entries(timeGroups)
    .map(([timeKey, data]) => {
      const [startTime, endTime] = timeKey.split('-');
      const dayNames = data.days.map(day => daysMap[day]).join('/');
      const locationStr = data.location ? ` ${data.location}` : '';
      return `${dayNames} ${startTime}-${endTime}${locationStr}`;
    })
    .join(', ');
}

/**
 * Converts MatrUFSC data into our timetable format
 */

/**
 * Converts MatrUFSC data into our timetable format
 */
export function parsescheduleData(data: any): ScheduleData {
  // Basic validation of input data
  if (!data || typeof data !== 'object') {
    return { professors: {} };
  }

  const result: ScheduleData = {
    professors: {}
  };


  // Helper logic to check if a value looks like campus data (array of courses)
  const isCampusArray = (val: any): boolean => {
    // Check if it's an array and the first item is a course array
    // Course array signature: [ID, Name, ...] (length >= 3)
    // We check valid types for ID (string) and potential classes array position
    if (!Array.isArray(val)) return false;
    if (val.length === 0) return true; // Empty array is valid campus data
    const first = val[0];
    return Array.isArray(first) && first.length >= 3;
  };

  const processCampusData = (campusData: any[]) => {
    campusData.forEach(course => {
      // Expecting [ID, Name, (Classes OR UpperName), (Classes?)]
      if (!Array.isArray(course) || course.length < 3) return;

      const courseId = course[0];

      // Determine classes index dynamically
      // Format 1: [ID, Name, Classes] (len 3)
      // Format 2: [ID, Name, UpperName, Classes] (len 4)
      let courseClasses: any[] | undefined;

      if (Array.isArray(course[2])) {
        courseClasses = course[2];
      } else if (course.length >= 4 && Array.isArray(course[3])) {
        courseClasses = course[3];
      }

      if (!courseId || !Array.isArray(courseClasses)) return;

      const courseSchedules: ClassSchedule[] = [];
      const professors: Professor[] = [];

      courseClasses.forEach(classInfo => {
        if (!Array.isArray(classInfo) || classInfo.length < 10) return;

        const classId = classInfo[0];
        const totalSlots = classInfo[3];
        const filledSlots = classInfo[4];
        const times = classInfo[8];
        const teachers = classInfo[9];

        // Process time slots
        const classSchedules: ClassSchedule[] = [];

        if (Array.isArray(times)) {
          times.forEach(time => {
            classSchedules.push(parseTimeString(time));
          });
        }

        // Add professor info
        const professorId = `${courseId}_${classId}`;
        const professorName = Array.isArray(teachers) ? teachers.join(', ') : "";

        professors.push({
          professorId,
          name: professorName,
          classNumber: classId,
          schedule: generateReadableSchedule(classSchedules),
          enrolledStudents: filledSlots,
          maxStudents: totalSlots
        });

        // Add schedules to course
        courseSchedules.push(...classSchedules);
      });

      // Store data in result
      if (courseSchedules.length > 0) {
        result[courseId] = courseSchedules;

        if (professors.length > 0) {
          result.professors[courseId] = professors;
        }
      }
    });
  };

  // Iterate over keys to find campus data
  // Supports both flat structures { "FLO": [...] } and nested { "208": { "FLO": [...] } }
  for (const key in data) {
    const val = data[key];

    // Case 1: The value itself is the campus data (e.g. key="FLO", val=[...])
    if (isCampusArray(val)) {
      processCampusData(val);
      continue;
    }

    // Case 2: The value is a degree object containing campus keys (e.g. key="208", val={ "FLO": [...] })
    if (val && typeof val === 'object') {
      Object.keys(val).forEach(subKey => {
        const subVal = val[subKey];
        if (isCampusArray(subVal)) {
          processCampusData(subVal);
        }
      });
    }
  }

  return result;
}

/**
 * Creates student courses from MatrUFSC courses
 */
export function createStudentCoursesFromMatrufsc(
  matrufscCourses: any[],
  status: CourseStatus = CourseStatus.IN_PROGRESS
): StudentCourse[] {
  return matrufscCourses
    .filter(course => Array.isArray(course) && course.length >= 3)
    .map(course => {
      const courseId = course[0];
      const courseTitle = course[1];

      // Determine classes index dynamically
      let courseClasses: any[] | undefined;

      if (Array.isArray(course[2])) {
        courseClasses = course[2];
      } else if (course.length >= 4 && Array.isArray(course[3])) {
        courseClasses = course[3];
      }

      // Get credits from first class
      let credits = 0;
      if (Array.isArray(courseClasses) && courseClasses.length > 0 && Array.isArray(courseClasses[0])) {
        credits = (courseClasses[0][1] as number) / 18;
      }

      // Create base course
      const courseObj: Course = {
        id: courseId,
        name: courseTitle,
        credits,
        phase: 0, // Default phase
      };

      // Create student course
      return {
        ...courseObj,
        course: courseObj,
        status,
        class: Array.isArray(courseClasses) && courseClasses.length > 0 && Array.isArray(courseClasses[0])
          ? courseClasses[0][0]
          : undefined
      } as StudentCourse;
    });
}

/**
 * Extracts data for a specific campus from MatrUFSC data
 */
export function extractCampusData(data: any, campusCode: string = 'FLO'): any {
  if (!data || typeof data !== 'object') return null;

  // Check if we have a nested structure with degree codes
  const keys = Object.keys(data);
  if (keys.length > 0) {
    const degreeCode = keys[0];

    // If the value is an object that has the campus code as a key
    if (data[degreeCode] && typeof data[degreeCode] === 'object' && data[degreeCode][campusCode]) {
      // Return just the campus data
      return { [campusCode]: data[degreeCode][campusCode] };
    }
  }

  // If we already have the campus code directly
  if (data[campusCode] && Array.isArray(data[campusCode])) {
    return data;
  }

  return null;
}
